-- [off & fx. hocketing potential.](https://tidalcycles.org/docs/reference/time/#off)
d7 $ off 0.5 (# squiz 8) $ n ("~ 7 2 [3 2]" |+ irand 6) # s "gabor"

-- spin. argument is number of copies, then copies are offset in time and space! amazing for multichannel](https://tidalcycles.org/docs/reference/time/#spin)

d7 $ spin 3 $ n ("~ 7 2 [3 2]" |+ irand 6) # s "gabor"

hush

-- poly meter? poly rhythm?...euclidean rhythm?
-- https://www.youtube.com/watch?v=bKazVnHh2w4 (@1:55)

-- poly

xfade 2 $ s "{print:5 gabba:5 print:2 gabba:6 print:4}%8"

d4 $ distrib [5, 9, 16] $ sound "print" # n "2 3 4"

d5
$ stack [struct "t(3,5)" $ s "gabba:6",
  struct "f(3,5)" $ s "gabba:3"]
  # shape (slow 2 saw)
  # gain 1.3
  # djf isaw
  # pan rand

d6
  $ sometimes (mask "[~ t t]")
  $ stitch "t(7,8)" (s "gabba:2") (s "print:5")
    # shape (slow 2 saw)
    # djf isaw
    # pan rand

    -- The 'arpy' folder contains sounds sampled using a pentatonic
    -- 'ritusen' scale, starting with 'c'. In this scale there are five
    -- notes per octave.  So these are the same notes:
    d1 $ n "0 5" # sound "arpy"

    d2 $ n "0 12" # sound "superpiano"

    -- Pentatonic scales like this are nice to work with because they all
    -- sound good together. So if we add a random note to a melody, it
    -- always sounds 'good':

    d1 $ n ("0 [7 2] 3 2" |+ irand 3) # sound "arpy"

    -- This isn't really the case on the usual twelve-tone "equal
    -- temperament" (12-TET) scale:
    d1 $ n ("0 [7 2] 3 2" |+ (irand 3)) # sound "superpiano"

    -- 12-TET is the scale that pianos etc are normally tuned to in the west.

    -- To use a different scale, we can use the "scale" function for converting
    -- numbers from a different scale to 12-TET.
    d1 $ n (scale "ritusen" $ "0 [7 2] 3 2" |+ (irand 3))
      # sound "superpiano"

    -- There's quite a few available:
    scaleList

    -- It's fun to use waveforms to pick notes from a scale. For example,
    -- use a smooth sinewave to select notes from a minor scale:
    d1 $ segment 16 $ n (scale "minor"
                         $ floor <$> (range 0 14 sine)
                        )
      # sound "supersaw"
      # legato 0.5
      # lpf 1000 # lpq 0.1

    -- Remember that waveforms don't have structure, so don't produce
    -- events until you use something like 'segment', which in the example
    -- above picks 16 notes per cycle.

    -- There's also a complication that waveforms produce 'floating point'
    -- decimal numbers, but scale only accepts 'integers' - whole numbers.
    -- The 'floor <$>' bit converts from decimal to whole numbers.  The
    -- "range 0 14" bit converts from the usual range of 0 to 1 to the
    -- given range of 0 to 14.

    -- We can make this more exciting by patterning the range:
    d1 $ segment 16 $ n (scale "minor"
                         $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine)
                        )
      # sound "supersaw"
      # legato 0.5
      # lpf 1000 # lpq 0.1

    -- And maybe even more exciting by using 'struct' to pattern the
    -- rhythm using Euclidean syntax.. Taking the opportunity to pattern
    -- the lpf (low pass filter) as well:
    d1 $ struct "t(<9 7>,16)"
      $ n (scale "minor"
            $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine)
          )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1


    -- Using scales in this way allows us to play with movement while
    -- still making tunes that make 'sense'. Here I add together
    -- waveforms to create some longer-form movement:
    d1 $ segment 16 $
      n (scale "minor"
          $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                      )
        )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1

    -- Back with the struct:
    d1 $ struct "t(<9 7>,16)" $
      n (scale "minor"
          $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                      )
        )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1

    -- And with an 'off' going up an octave:
    d1 $ off 0.25 (|+ n 12) $ struct "t(<9 7>,16)" $ segment 16 $
      n (scale "minor"
          $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"
                      )
        )
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1

    -- Note that in the above the 'off' is outside of the 'scale'
    -- function, So we're back in 12-TET land, so add '12' to go up an
    -- octave, rather than the number of notes in the minor scale (7)

    d1 $ ur 16 "[bdsd, ~ claps, ~ [bass bass:crunch] ~ bass]"
  [("bdsd", sound "bd [~ sd] bd sd" # squiz 2),
   ("claps", sound "clap:4*2 clap:4*3"
     # delay 0.8 # dt "t" # dfb 0.4
     # orbit 4 # speed 4
   ),
   ("bass", struct "t(3,8)" $ sound "dbass" # shape 0.7 # speed "[1, ~ 2]")
  ]
  [("crunch", (# crush 3))
  ]

  -- Binary patterns

-- The patterns you send to SuperDirt tend to contain values of type
-- String (for words), Double (for decimal numbers) or Int (for whole
-- numbers). One pattern type you probably won't send to SuperDirt is
-- of type Bool - short for Boolean.

-- Boolean values can be either True or False. You've probably seen
-- then used with with 'struct', e.g.:

d1 $ struct "t f t t f t f f" $ sound "snare:4"

-- 'struct' provides structure for the pattern on the right; whenever
-- there's a 't' (i.e., a true value) in the boolean pattern, the
-- snare fires.

-- It works with euclidean syntax too:
d1 $ struct "t(3,8)" $ sound "snare:4"

-- The above creates a new pattern with three events per cycle,
-- according to a Euclidean pattern.

-- Lets have a look at that euclidean pattern:
drawLine $ struct "t(3,8)" "a"

-- So what do you think would happen if you changed that 't' (for
-- true) for an 'f' (for false)? Lets try:
drawLine $ struct "f(3,8)" "a"

-- Lets listen to that structure too:
d1 $ struct "f(3,8)" $ sound "snare:4"

-- You can see and hear that the *inverse* of the Euclidean pattern is
-- played. What was true, is now false, and vice-versa.. It's the
-- 'empty' steps which get the true values, and which we end up
-- hearing.

-- This is clearer if we play a t(3,8) against an inverted f(3,8):
d1 $ stack [struct "t(3,8)" $ sound "kick:4",
            struct "f(3,8)" $ sound "snare:4"
           ]

-- You can hear that the snares are 'filling in' where the kicks
-- aren't playing - they never play at the same time.

-- Filling in patterns like this is a lot of fun, and there's a
-- function called 'stitch' that makes it easier:
d1 $ stitch "t(3,8)" (sound "kick:4") (sound "snare:4")

-- You only have to give the boolean pattern once, 'stitch' takes care
-- of inverting the pattern for the second pattern. It's called
-- 'stitch', because it's like going up and down to stitch two things
-- together.

-- You can make more complicated boolean patterns to quickly get some
-- fun patterns going:
d1 $ stitch "t(<3 5>,8,<0 2 3>)" (sound "kick:4") (sound "hc")

d1 $ stitch "t(<3 5>,<8 8 8 6>,<0 2 4>)" (sound "kick:4") (sound "hc")

-- Actually it'd be less typing do the stitching _inside_ the sound
-- control pattern:
d1 $ sound (stitch "t(<3 5>,<8 8 8 6>,<0 2 4>)" "kick:4" "hc")

-- In the above, I only have to write 'sound' once, because the
-- 'stitch' is working on patterns of words, not patterns of sounds.

-- You can also alternate between patterns of true, and patterns of false
-- values:
drawLine $ struct "<t f>(3,8)" "a"

-- If you prefer you can use '1' or '0' instead of 't' and 'f', the
-- result is exactly the same:
drawLine $ struct "<1 0>(3,8)" "a"

d1 $ struct "<1 0>(3,8)" $ sound "clap"

-- You don't have to use the Euclidean syntax, you can just right them
-- out by hand:
d1 $ stitch "t f t t f f t f" (sound "kick:4") (sound "hc")

-- .. and use the usual mininotation syntax:
d1 $ stitch "t f t [t f]*2 f ~ t f" (sound "kick:4") (sound "hc")
  # room 0.2 # sz 0.8

-- With stitch, the rhythmic structure comes from the boolean
-- pattern. It has a synonym friend called 'sew', which instead
-- preserves the structure of the patterns it's sewing together.

-- Lets try it:
d1 $ sew "t f" (sound "kick") (sound "clap:4")

-- Oh! We only hear the kick. That's because the 'f' only switches to
-- the second pattern for the second half of the cycle, and no new
-- 'clap's happen then.

-- If we have four claps spread over the cycle, we hear the second two
-- of them:
d1 $ sew "t f" (sound "kick") (sound "clap:4*4")

-- Sew can be really nice for blending together two more complicated
-- patterns. Lets have a listen to them individually first:

d1 $ chunk 4 (hurry 2) $ n "0 .. 7" # sound "cpu"

d1 $ n "0 .. 7" # sound "cpu2" # speed 1.5 # squiz 2

-- And now sewn:
d1 $ sew (iter 4 "t f")
  (chunk 4 (hurry 2) $ n "0 .. 7" # sound "cpu")
  (n "0 .. 7" # sound "cpu2" # speed 1.5 # squiz 2)

-- In the above I have a really simple "t f" binary pattern, but use
-- 'iter 4' so that it shifts by a quarter every cycle.. So you get
-- different parts of the sewn patterns coming through.

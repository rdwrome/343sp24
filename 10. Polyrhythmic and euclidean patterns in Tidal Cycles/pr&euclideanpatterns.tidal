-- [off & fx. hocketing potential.](https://tidalcycles.org/docs/reference/time/#off)
d7 $ off 0.5 (# squiz 8) $ n ("~ 7 2 [3 2]" |+ irand 6) # s "gabor"

-- spin. argument is number of copies, then copies are offset in time and space! amazing for multichannel](https://tidalcycles.org/docs/reference/time/#spin)

d7 $ spin 3 $ n ("~ 7 2 [3 2]" |+ irand 6) # s "gabor"

hush

-- poly meter? poly rhythm?...euclidean rhythm?
-- https://www.youtube.com/watch?v=bKazVnHh2w4 (@1:55)

--Polymetric sequence with argument for steps per cycle
d1 $ s "{bd cp hh}%4"

--Euclidean Rhythm
-- syntax sugar
--MiniTidal Euclidean Rhythm
d1 $ "reverbkick(9,16)"
-- this was short for
d1 $ "e(9,16)" # s "reverbkick"
-- which itself was short for
d1 $ euclid 9 16 $ s "reverbkick"
-- in all of these:
  -- first argument is the pulses per cycle
  -- second argument is the steps per cycle
  -- advantages of longer syntax is more places to add parameters
-- this is also the same:
d1 $ distrib [9,16] $ s "reverbkick"
-- but, there is a third argument...
d1 $ distrib [9,16,5] $ sound "reverbkick"

-- EXCERPTS FROM ALEX MCLEAN'S WORKSHOPS

-- There's quite a few scales available:
  scaleList

-- It's fun to use waveforms to pick notes from a scale. For example,
-- use a smooth sinewave to select notes from a minor scale:
d1
$ segment 16
$ n (scale "minor" $ floor <$> (range 0 14 sine))
  # sound "supersaw"
  # legato 0.5
  # lpf 1000
  # lpq 0.1

-- Remember that waveforms don't have structure, so don't produce
-- events until you use something like 'segment', which in the example
-- above picks 16 notes per cycle.
-- There's also a complication that waveforms produce 'floating point'
-- decimal numbers, but scale only accepts 'integers' - whole numbers.
-- The 'floor <$>' bit converts from decimal to whole numbers.  The
-- "range 0 14" bit converts from the usual range of 0 to 1 to the
-- given range of 0 to 14.

-- We can make this more exciting by patterning the range:
d1
$ segment 16
$ n (scale "minor" $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine))
  # sound "supersaw"
  # legato 0.5
  # lpf 1000
  # lpq 0.1

-- And maybe even more exciting by using 'struct' to pattern the
-- rhythm using Euclidean syntax.. Taking the opportunity to pattern
-- the lpf (low pass filter) as well:
d1
$ struct "t(<9 7>,16)"
$ n (scale "minor" $ floor <$> (range "<0 4 -8>" "<12 14 13 -13>" sine))
  # sound "supersaw"
  # legato 0.5
  # lpf (range 400 5000 saw)
  # lpq 0.1

-- Using scales in this way allows us to play with movement while
-- still making tunes that make 'sense'. Here I add together
-- waveforms to create some longer-form movement:
d1 $ segment 16
$ n (scale "minor" $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"))
  # sound "supersaw"
  # legato 0.5
  # lpf (range 400 5000 saw)
  # lpq 0.1

-- Back with the struct:
d1
$ struct "t(<9 7>,16)"
$ n (scale "minor" $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"))
    # sound "supersaw"
    # legato 0.5
    # lpf (range 400 5000 saw)
    # lpq 0.1

-- And with an 'off' going up an octave:
d1
$ off 0.25 (|+ n 12)
$ struct "t(<9 7>,16)"
$ segment 16
$ n (scale "minor" $ floor <$> (slow 2 $ (slow 2 sine + slow 3 cosine) * "<6 -3>"))
      # sound "supersaw"
      # legato 0.5
      # lpf (range 400 5000 saw) # lpq 0.1
-- Note that in the above the 'off' is outside of the 'scale'
-- function, So we're back in 12-TET land, so add '12' to go up an
-- octave, rather than the number of notes in the minor scale (7)



-- Binary patterns
-- The patterns you send to SuperDirt tend to contain values of type
-- String (for words), Double (for decimal numbers) or Int (for whole
-- numbers). One pattern type you probably won't send to SuperDirt is
-- of type Bool - short for Boolean.

-- Boolean values can be either True or False. You've probably seen
-- then used with with 'struct', e.g.:

d1 $ struct "t f t t f t f f" $ sound "wobble"

-- 'struct' provides structure for the pattern on the right; whenever
-- there's a 't' (i.e., a true value) in the boolean pattern, the
-- snare fires.

-- It works with euclidean syntax too:
d1 $ struct "t(3,8)" $ sound "wobble"

-- The above creates a new pattern with three events per cycle,
-- according to a Euclidean pattern.

-- Lets have a look at that euclidean pattern:
drawLine $ struct "t(3,8)" "a"

-- So what do you think would happen if you changed that 't' (for
-- true) for an 'f' (for false)? Lets try:
drawLine $ struct "f(3,8)" "a"

-- Lets listen to that structure too:
d1 $ struct "f(3,8)" $ sound "gabba:4"

-- You can see and hear that the *inverse* of the Euclidean pattern is
-- played. What was true, is now false, and vice-versa.. It's the
-- 'empty' steps which get the true values, and which we end up
-- hearing.

-- This is clearer if we play a t(3,8) against an inverted f(3,8):
d1 $ stack [struct "t(3,8)" $ sound "gabba:4",
            struct "f(3,8)" $ sound "gabba:5"
           ]

-- Filling in patterns like this is a lot of fun, and there's a
-- function called 'stitch' that makes it easier:
d1 $ stitch "t(3,8)" (sound "gabba:4") (sound "gabba:5")
-- You only have to give the boolean pattern once, 'stitch' takes care
-- of inverting the pattern for the second pattern. It's called
-- 'stitch', because it's like going up and down to stitch two things
-- together...

-- You can also alternate between patterns of true, and patterns of false
-- values:
drawLine $ struct "<t f>(3,8)" "a"

-- If you prefer you can use '1' or '0' instead of 't' and 'f', the
-- result is exactly the same:
drawLine $ struct "<1 0>(3,8)" "a"

d1 $ struct "<1 0>(3,8)" $ sound "reverbkick"

-- You don't have to use the Euclidean syntax, you can just right them
-- out by hand:
d1 $ stitch "t f t t f f t f" (sound "print:4") (sound "909")

-- .. and use the usual mininotation syntax:
d1 $ stitch "t f t [t f]*2 f ~ t f" (sound "print:4") (sound "909")
  # room 0.2 # sz 0.8

-- With stitch, the rhythmic structure comes from the boolean
-- pattern. It has a synonym friend called 'sew', which instead
-- preserves the structure of the patterns it's sewing together.

-- Lets try it:
d1 $ sew "t f" (sound "print:4") (sound "909")

-- Oh! We only hear the kick. That's because the 'f' only switches to
-- the second pattern for the second half of the cycle, and no new
-- 'clap's happen then.

-- If we have four claps spread over the cycle, we hear the second two
-- of them:
d1 $ sew "t f" (sound "print:4") (sound "909*4")

-- Sew can be really nice for blending together two more complicated
-- patterns. Lets have a listen to them individually first:

d1 $ chunk 4 (hurry 2) $ n "0 .. 7" # sound "imp"

d1 $ n "0 .. 7" # sound "imp" # speed 1.5 # squiz 2

-- And now sewn:
d1 $ sew (iter 4 "t f")
  (chunk 4 (hurry 2) $ n "0 .. 7" # sound "imp")
  (n "0 .. 7" # sound "imp" # speed 1.5 # squiz 2)

-- In the above I have a really simple "t f" binary pattern, but use
-- 'iter 4' so that it shifts by a quarter every cycle.. So you get
-- different parts of the sewn patterns coming through.
